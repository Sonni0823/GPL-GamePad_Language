<div contenteditable="true" translate="no" class="ProseMirror"><h1>🎮 GPL (Gamepad Language) Compiler Project</h1><blockquote><p><strong>"키보드는 필요 없다. 오직 컨트롤러만 있을 뿐."</strong>
GPL은 텍스트 타이핑 대신 게임 패드 버튼 입력 시퀀스를 소스 코드로 사용하는 난해한 프로그래밍 언어(Esolang) 컴파일러입니다.</p></blockquote><h2>📋 프로젝트 개요 (Overview)</h2><p>**GPL(Gamepad Language)**은 전통적인 프로그래밍 언어의 텍스트 중심 문법을 타파하고, 제한된 입력 장치인 '게임 패드'의 버튼 입력만을 사용하여 튜링 완전(Turing Complete)한 로직을 구현하는 것을 목표로 하는 실험적인 프로젝트입니다.</p><p>사용자는 <code>int</code>, <code>if</code>, <code>while</code> 같은 키워드 대신 <code>A</code>, <code>B</code>, <code>START</code>, <code>UP</code> 등의 버튼 이름을 조합하여 코드를 작성하며, 이 컴파일러는 해당 입력을 분석하여 실제 실행 가능한 **x86-64 기계어(Assembly)**로 변환합니다.</p><h2>🛠 기술 스택 (Tech Stack)</h2><p>본 프로젝트는 컴파일러 구축의 정석적인 기술 스택을 기반으로 합니다.</p><ul><li><p><strong>Language:</strong> C (C11 Standard)</p></li><li><p><strong>Lexer (Scanner):</strong> Flex (Fast Lexical Analyzer Generator)</p></li><li><p><strong>Parser:</strong> Bison (GNU Parser Generator)</p></li><li><p><strong>Target Architecture:</strong> x86-64 Assembly (AT&amp;T Syntax)</p></li><li><p><strong>Build System:</strong> Make, GCC</p></li><li><p><strong>Environment:</strong> Linux (Ubuntu/Debian based)</p></li></ul><h2>🕹 언어 명세 (Language Specification)</h2><p>GPL은 C언어의 부분 집합(Subset)을 기반으로 하지만, 입력 방식의 제약으로 인해 고유한 문법 체계를 가집니다.</p><h3>1. 버튼 매핑 (Button Mapping)</h3><table><tbody><tr><th><p>버튼 (Token)</p></th><th><p>의미 (Semantics)</p></th><th><p>C언어 대응</p></th><th><p>비고</p></th></tr><tr><td><p><strong>START</strong></p></td><td><p>Program Begin</p></td><td><p><code>main() {</code></p></td><td><p>프로그램의 시작점</p></td></tr><tr><td><p><strong>SELECT</strong></p></td><td><p>Program End</p></td><td><p><code>return 0; }</code></p></td><td><p>프로그램의 종료점</p></td></tr><tr><td><p><strong>A</strong></p></td><td><p>Declare Variable</p></td><td><p><code>int</code></p></td><td><p>변수 선언 (자동으로 0 초기화)</p></td></tr><tr><td><p><strong>B</strong></p></td><td><p>Loop</p></td><td><p><code>while</code></p></td><td><p>반복문 시작</p></td></tr><tr><td><p><strong>Y</strong></p></td><td><p>Condition</p></td><td><p><code>if</code></p></td><td><p>조건문 시작</p></td></tr><tr><td><p><strong>X</strong></p></td><td><p>Assign</p></td><td><p><code>=</code></p></td><td><p>값 대입</p></td></tr><tr><td><p><strong>UP</strong></p></td><td><p>Increment / Add</p></td><td><p><code>+</code> / <code>1</code></p></td><td><p>덧셈 연산자이자 숫자 1의 역할</p></td></tr><tr><td><p><strong>DOWN</strong></p></td><td><p>Decrement / Sub</p></td><td><p><code>-</code></p></td><td><p>뺄셈 연산자</p></td></tr><tr><td><p><strong>LEFT</strong></p></td><td><p>Multiply</p></td><td><p><code>*</code></p></td><td><p>곱셈 연산자 (높은 우선순위)</p></td></tr><tr><td><p><strong>LB</strong></p></td><td><p>Print</p></td><td><p><code>printf</code></p></td><td><p>변수 값 출력</p></td></tr><tr><td><p><strong>RB</strong></p></td><td><p>End Statement</p></td><td><p><code>;</code></p></td><td><p>문장의 마침표</p></td></tr><tr><td><p><strong>LT / RT</strong></p></td><td><p>Block Start/End</p></td><td><p><code>{</code> / <code>}</code></p></td><td><p>스코프 블록 지정</p></td></tr><tr><td><p><strong>L1 / R1</strong></p></td><td><p>Register (Var)</p></td><td><p><code>var</code></p></td><td><p>사용 가능한 고정 레지스터(변수)</p></td></tr></tbody></table><h3>2. 수 체계 (Numeric System)</h3><p>GPL에는 숫자 리터럴(예: <code>100</code>, <code>52</code>)이 존재하지 않습니다. 모든 수는 <strong>단항(Unary) 방식</strong>으로 생성해야 합니다.</p><ul><li><p><strong>기본값:</strong> 변수 선언(<code>A L1 RB</code>) 시 값은 <code>0</code>입니다.</p></li><li><p><strong>값 생성:</strong> <code>UP</code> 버튼을 눌러 값을 1씩 증가시킵니다.</p><ul><li><p>예: 숫자 3 표현 -&gt; <code>UP UP UP</code></p></li></ul></li></ul><h3>3. 코드 예시 (Code Example)</h3><p><strong>목표:</strong> 변수 <code>L1</code>에 3을 넣고, <code>R1</code>에 2를 넣은 뒤 곱해서 출력하기.</p><pre><code>START                   // 프로그램 시작
  A L1 RB               // int L1 = 0;
  L1 X UP UP UP RB      // L1 = 0 + 1 + 1 + 1; (L1은 3)

  A R1 RB               // int R1 = 0;
  R1 X UP UP RB         // R1 = 0 + 1 + 1; (R1은 2)

  L1 X L1 LEFT R1 RB    // L1 = L1 * R1; (3 * 2 = 6)
  LB L1 RB              // printf(L1);
SELECT                  // 종료
<br class="ProseMirror-trailingBreak"></code></pre><h2>⚙️ 컴파일러 구현 상세 (Implementation Details)</h2><h3>1. Frontend: 어휘 및 구문 분석 (Lexer &amp; Parser)</h3><ul><li><p><strong>Scanner (<code>scanner.l</code>):</strong> 정규 표현식을 사용하여 <code>START</code>, <code>A</code>, <code>UP</code> 등의 텍스트 스트림을 토큰으로 변환합니다. 기존의 숫자(<code>[0-9]+</code>) 인식 로직을 제거하고, 고정된 변수명(<code>L1</code>, <code>R1</code>)을 식별자로 처리합니다.</p></li><li><p><strong>Parser (<code>parser.y</code>):</strong> <code>program</code>, <code>stmt</code>, <code>expr</code> 로 이어지는 BNF 문법을 정의합니다.</p><ul><li><p><code>program</code>은 반드시 <code>START</code> 토큰으로 시작해 <code>SELECT</code> 토큰으로 끝나도록 강제됩니다.</p></li><li><p><code>expr</code> 규칙에서 <code>UP</code>과 <code>DOWN</code> 토큰 자체를 정수 <code>1</code>로 평가하여 연산과 피연산자의 역할을 동시에 수행하게 했습니다.</p></li></ul></li></ul><h3>2. Middle-end: 추상 구문 트리 (AST)</h3><ul><li><p><strong>AST (<code>ast.c/h</code>):</strong> 파싱된 코드를 트리 구조로 변환합니다.</p></li><li><p><code>AST_VAR_DECL</code> 노드는 변수 선언을 의미하며, <code>AST_ADD</code>, <code>AST_SUB</code> 등은 이진 트리 형태로 연산 순서를 보장합니다.</p></li></ul><h3>3. Backend: 코드 생성 (Code Generator)</h3><ul><li><p><strong>CodeGen (<code>codegen_x86.c</code>):</strong> AST를 순회하며 x86-64 어셈블리 코드를 생성합니다.</p></li><li><p><strong>스택 머신 (Stack Machine):</strong> 연산 시 <code>%rax</code>, <code>%rbx</code> 레지스터와 스택(<code>push</code>, <code>pop</code>)을 활용하여 복잡한 수식도 순차적으로 계산합니다.</p></li><li><p><strong>자동 초기화:</strong> GPL의 특성상(<code>UP</code>으로 수 증가), 변수 선언 노드 방문 시 해당 메모리 주소를 즉시 <code>0</code>으로 초기화하는 로직(<code>movl $0, -offset(%rbp)</code>)이 추가되었습니다.</p></li></ul><h2>🎓 프로젝트의 의의 및 기대 효과</h2><ol><li><p><strong>튜링 완전성 증명 (Turing Completeness):</strong></p><ul><li><p>GPL은 제한된 명령어(증감, 분기, 반복)만으로 모든 계산 가능한 문제를 해결할 수 있음을 보여줍니다. 이는 컴퓨터 과학의 <strong>카운터 머신(Counter Machine)</strong> 이론을 직접 구현한 사례입니다.</p></li></ul></li><li><p><strong>컴파일러 구조의 이해:</strong></p><ul><li><p>텍스트가 어떻게 기계어로 번역되는지, 그리고 문법(Syntax)이라는 것이 얼마나 임의적(Arbitrary)인 약속인지 깊이 이해할 수 있습니다.</p></li></ul></li><li><p><strong>제약 속의 창의성:</strong></p><ul><li><p>숫자 키 없이 큰 수를 만들거나, 한정된 변수로 복잡한 로직을 짤 때 알고리즘적 사고력이 극대화됩니다.</p></li></ul></li></ol><h2>🚀 실행 방법 (How to Run)</h2><ol><li><p><strong>빌드:</strong></p><pre><code>make
<br class="ProseMirror-trailingBreak"></code></pre><p><code>minic_x86</code> 컴파일러가 생성됩니다.</p></li><li><p><strong>GPL 코드 작성:</strong>
<code>test.gpl</code> 파일에 버튼 코드를 작성합니다.</p></li><li><p><strong>컴파일 및 실행:</strong></p><pre><code>./minic_x86 test.gpl    # out.s (어셈블리) 생성
make prog               # 실행 파일(prog) 생성
./prog                  # 결과 확인
<br class="ProseMirror-trailingBreak"></code></pre></li></ol><p><em>Created by Sonni0823 using GCC &amp; Flex/Bison toolkit.</em></p></div>
